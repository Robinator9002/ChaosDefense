# game_logic/progression/player_data_manager.py
import json
import logging
from pathlib import Path
from dataclasses import dataclass, field
from typing import List, Set, Dict, Any

logger = logging.getLogger(__name__)


@dataclass
class PlayerData:
    """
    A data class that holds all persistent player progression data.
    MODIFIED: Removed hardcoded default values. Default data is now
              generated by the PlayerDataManager from game_settings.json.
    """

    meta_currency: int
    unlocked_towers: Set[str]
    unlocked_levels: Set[str]
    purchased_upgrades: Set[str] = field(default_factory=set)
    highest_wave_reached: int = 0


class PlayerDataManager:
    """
    Manages the loading from and saving to the player's persistent data file.
    This class handles all file I/O operations for player progression.
    """

    # --- MODIFIED: Constructor now accepts game_settings ---
    # This is necessary to read the initial player stats from the config file.
    def __init__(self, save_path: Path, game_settings: Dict[str, Any]):
        """
        Initializes the PlayerDataManager.

        Args:
            save_path (Path): The full path to the player_data.json save file.
            game_settings (Dict[str, Any]): The loaded game_settings.json config.
        """
        self.save_path = save_path
        # --- NEW: Store game_settings ---
        self.game_settings = game_settings
        self.data: PlayerData = self._load_or_create_data()

    def _load_or_create_data(self) -> PlayerData:
        """
        Loads player data from the save file. If the file doesn't exist or is
        corrupt, it creates a new default save file using game_settings.json.

        Returns:
            PlayerData: An instance of the PlayerData class.
        """
        if self.save_path.exists() and self.save_path.is_file():
            try:
                with open(self.save_path, "r") as f:
                    data = json.load(f)
                    # Convert lists from JSON back to sets for efficient lookups
                    data["unlocked_towers"] = set(data.get("unlocked_towers", []))
                    data["purchased_upgrades"] = set(data.get("purchased_upgrades", []))
                    # Keep a fallback for old save files that don't have this key
                    data["unlocked_levels"] = set(
                        data.get("unlocked_levels", ["Forest"])
                    )

                    logger.info(
                        f"Player data loaded successfully from {self.save_path}"
                    )
                    return PlayerData(**data)
            except (json.JSONDecodeError, TypeError, KeyError) as e:
                logger.error(
                    f"Failed to load or parse player data from {self.save_path}: {e}. "
                    "Creating a new default save file."
                )

        return self._create_default_data()

    def _create_default_data(self) -> PlayerData:
        """
        Creates a new PlayerData object with default values read from
        game_settings.json and saves it to disk.

        Returns:
            PlayerData: A new instance of PlayerData with default starting values.
        """
        logger.warning(
            f"No valid save file found. Creating new player data at {self.save_path}"
        )

        # --- MODIFIED: Read initial values from game_settings.json ---
        # This makes the starting player state entirely data-driven.
        initial_shards = self.game_settings.get("initial_chaos_shards", 0)
        initial_towers = set(
            self.game_settings.get("initial_unlocked_towers", ["turret"])
        )

        default_data = PlayerData(
            meta_currency=initial_shards,
            unlocked_towers=initial_towers,
            unlocked_levels={"Forest"},  # The first level is always unlocked
            purchased_upgrades=set(),
            highest_wave_reached=0,
        )

        self.save_data(default_data)
        return default_data

    def save_data(self, player_data: PlayerData):
        """
        Saves the provided PlayerData object to the JSON file.

        Args:
            player_data (PlayerData): The data object to save.
        """
        self.save_path.parent.mkdir(parents=True, exist_ok=True)

        save_dict = {
            "meta_currency": player_data.meta_currency,
            "unlocked_towers": list(player_data.unlocked_towers),
            "unlocked_levels": list(player_data.unlocked_levels),
            "purchased_upgrades": list(player_data.purchased_upgrades),
            "highest_wave_reached": player_data.highest_wave_reached,
        }

        try:
            with open(self.save_path, "w") as f:
                json.dump(save_dict, f, indent=2)
            logger.info(f"Player data saved successfully to {self.save_path}")
        except IOError as e:
            logger.critical(
                f"CRITICAL: Could not write player data to {self.save_path}: {e}"
            )

    def get_data(self) -> PlayerData:
        """
        Provides access to the currently loaded player data.

        Returns:
            PlayerData: The active PlayerData object.
        """
        return self.data
